!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/n/irc/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	//
$(DEBUG_DIR)/%.o	1MAIN/Makefile	/^$(DEBUG_DIR)\/%.o: $(SRC_DIR)\/%.cpp$/;"	t
$(NAME)	0HELPER/poll/Makefile	/^$(NAME): $(OBJECTS)$/;"	t
$(NAME)	1MAIN/Makefile	/^$(NAME): $(OBJS)$/;"	t
$(NAME)	2TEST/Makefile	/^$(NAME): $(OBJECTS)$/;"	t
$(NAME)	helper/test_buid/Makefile	/^$(NAME): $(OBJECTS)$/;"	t
$(NAME)_debug	1MAIN/Makefile	/^$(NAME)_debug: $(DEBUG_OBJS)$/;"	t
$(OBJ_DIR)/%.o	1MAIN/Makefile	/^$(OBJ_DIR)\/%.o: $(SRC_DIR)\/%.cpp$/;"	t
./objects/%.o	0HELPER/poll/Makefile	/^.\/objects\/%.o: .\/%.cpp$/;"	t
./objects/%.o	2TEST/Makefile	/^.\/objects\/%.o: .\/%.cpp$/;"	t
./objects/%.o	helper/test_buid/Makefile	/^.\/objects\/%.o: .\/%.cpp$/;"	t
2ybSh1EJTlHTt2kOWbFA5smaoO8	.idea/workspace.xml	/^  <component name="ProjectId" id="2ybSh1EJTlHTt2kOWbFA5smaoO8" \/>$/;"	i
8e611e76-f236-46f4-9d68-2162b12a1cd5	.idea/workspace.xml	/^      <changelist id="8e611e76-f236-46f4-9d68-2162b12a1cd5" name="Changes" comment="" \/>$/;"	i
8e611e76-f236-46f4-9d68-2162b12a1cd5	.idea/workspace.xml	/^    <list default="true" id="8e611e76-f236-46f4-9d68-2162b12a1cd5" name="Changes" comment="">$/;"	i
Add	.idea/workspace.xml	/^    <ConfirmationsSetting value="2" id="Add" \/>$/;"	i
BUFFER_SIZE	1MAIN/include/main.hpp	/^# define BUFFER_SIZE /;"	d
BUFFER_SIZE	2TEST/new_main.cpp	/^#define BUFFER_SIZE /;"	d	file:
BUFFER_SIZE	2TEST/old_main.cpp	/^#define BUFFER_SIZE /;"	d	file:
CAPABILITIES_H	1MAIN/include/capabilities.hpp	/^# define CAPABILITIES_H$/;"	d
CHANOP	1MAIN/include/Channel.hpp	/^# define CHANOP /;"	d
CHAN_OP	1MAIN/include/Channel.hpp	/^# define CHAN_OP /;"	d
CLIENT_HPP	1MAIN/include/Client.hpp	/^# define CLIENT_HPP$/;"	d
COMPILATOR	0HELPER/poll/Makefile	/^COMPILATOR = c++$/;"	m
COMPILATOR	2TEST/Makefile	/^COMPILATOR = c++$/;"	m
COMPILATOR	helper/test_buid/Makefile	/^COMPILATOR = c++$/;"	m
CXX	1MAIN/Makefile	/^CXX = c++$/;"	m
Channel	1MAIN/include/Channel.hpp	/^class Channel {$/;"	c
Channel	1MAIN/src/Channel.cpp	/^Channel::Channel() {}$/;"	f	class:Channel
Channel	1MAIN/src/Channel.cpp	/^Channel::Channel(Client &client, std::string &name) {$/;"	f	class:Channel
Client	1MAIN/include/Client.hpp	/^class Client$/;"	c
Client	1MAIN/src/Client.cpp	/^Client::Client(Server* server)$/;"	f	class:Client
Client	1MAIN/src/Client.cpp	/^Client::Client(void)$/;"	f	class:Client
CommandFunc	1MAIN/include/Handle.hpp	/^typedef void (*CommandFunc)(Server &server, Client &client, std::string input);$/;"	t	typeref:typename:void (*)(Server & server,Client & client,std::string input)
CustomElementImpl	3UMLET/custom_elements/AutoResize1.java	/^	public CustomElementImpl() {$/;"	m	class:__anon1
CustomElementImpl	3UMLET/custom_elements/AutoResize2.java	/^	public CustomElementImpl() {$/;"	m	class:__anon1
CustomElementImpl	3UMLET/custom_elements/Default.java	/^	public CustomElementImpl() {$/;"	m	class:__anon1
CustomElementImpl	3UMLET/custom_elements/RectangleRound.java	/^	public CustomElementImpl() {$/;"	m	class:__anon1
CustomElementImpl	3UMLET/custom_elements/WordWrap.java	/^	public CustomElementImpl() {$/;"	m	class:__anon1
DEBUG_DIR	1MAIN/Makefile	/^DEBUG_DIR = debug$/;"	m
DEBUG_FLAGS	1MAIN/Makefile	/^DEBUG_FLAGS = -g3 -O0 -DDEBUG$/;"	m
DEBUG_OBJS	1MAIN/Makefile	/^DEBUG_OBJS = $(SRCS:%.cpp=$(DEBUG_DIR)\/%.o)$/;"	m
Default	.idea/workspace.xml	/^    <task active="true" id="Default" summary="Default task">$/;"	i
FILES	0HELPER/poll/Makefile	/^FILES = main \\$/;"	m
FILES	2TEST/Makefile	/^FILES = new_main \\$/;"	m
FILES	helper/test_buid/Makefile	/^FILES = main \\$/;"	m
GETTER_SETTER	1MAIN/include/main.hpp	/^#define GETTER_SETTER(/;"	d
HALFOP	1MAIN/include/Channel.hpp	/^# define HALFOP /;"	d
HANDLE_HPP	1MAIN/include/Handle.hpp	/^#define HANDLE_HPP$/;"	d
INCLUDE_DIR	1MAIN/Makefile	/^INCLUDE_DIR = include$/;"	m
INVITE_ONLY	1MAIN/include/Channel.hpp	/^# define INVITE_ONLY /;"	d
IPv4_client_sock_addr	1MAIN/include/Client.hpp	/^	struct sockaddr_in	IPv4_client_sock_addr;$/;"	m	class:Client	typeref:struct:sockaddr_in
IPv4_serv_sock_addr	1MAIN/include/Server.hpp	/^	struct sockaddr_in	IPv4_serv_sock_addr;$/;"	m	class:Server	typeref:struct:sockaddr_in
IRC_CHANNEL_H	1MAIN/include/Channel.hpp	/^#define IRC_CHANNEL_H$/;"	d
KEY	1MAIN/include/Channel.hpp	/^# define KEY /;"	d
LEN_MAX_NAME	1MAIN/include/utils_strings.hpp	/^# define LEN_MAX_NAME /;"	d
LIMIT	1MAIN/include/Channel.hpp	/^# define LIMIT /;"	d
LOGGED	1MAIN/include/Client.hpp	/^# define LOGGED /;"	d
LOG_IN	1MAIN/include/Client.hpp	/^# define LOG_IN /;"	d
MAIN_HPP	1MAIN/include/main.hpp	/^# define MAIN_HPP$/;"	d
MAX_CHANNELS	1MAIN/include/Channel.hpp	/^# define MAX_CHANNELS /;"	d
MAX_CLIENTS	1MAIN/include/main.hpp	/^# define MAX_CLIENTS /;"	d
MAX_CLIENTS	2TEST/new_main.cpp	/^#define MAX_CLIENTS /;"	d	file:
MAX_CONNECTIONS	1MAIN/include/main.hpp	/^# define MAX_CONNECTIONS /;"	d
MAX_CONNECTIONS	2TEST/new_main.cpp	/^#define MAX_CONNECTIONS /;"	d	file:
NAME	0HELPER/poll/Makefile	/^NAME = poll_test$/;"	m
NAME	1MAIN/Makefile	/^NAME = ircserv$/;"	m
NAME	2TEST/Makefile	/^NAME = test_ircserv$/;"	m
NAME	helper/test_buid/Makefile	/^NAME = test_ircserv$/;"	m
OBJECTS	0HELPER/poll/Makefile	/^OBJECTS = $(foreach f, $(FILES), .\/$(f).o)$/;"	m
OBJECTS	2TEST/Makefile	/^OBJECTS = $(foreach f, $(FILES), .\/$(f).o)$/;"	m
OBJECTS	helper/test_buid/Makefile	/^OBJECTS = $(foreach f, $(FILES), .\/$(f).o)$/;"	m
OBJS	1MAIN/Makefile	/^OBJS = $(SRCS:%.cpp=$(OBJ_DIR)\/%.o)$/;"	m
OBJ_DIR	1MAIN/Makefile	/^OBJ_DIR = obj$/;"	m
OFLAGS	0HELPER/poll/Makefile	/^OFLAGS = -std=c++98 -Wall -Wextra -Werror -I.\/includes -pedantic -g3 -fsanitize=leak,address,un/;"	m
OFLAGS	2TEST/Makefile	/^OFLAGS = -std=c++98 -Wall -Wextra -Werror -I.\/includes -pedantic -g3 -fsanitize=leak,address,un/;"	m
OFLAGS	helper/test_buid/Makefile	/^OFLAGS = -std=c++98 -Wall -Wextra -Werror -I.\/includes -pedantic -g3 -fsanitize=leak,address,un/;"	m
OP	1MAIN/include/Channel.hpp	/^# define OP /;"	d
OPERATOR_OP	1MAIN/include/Channel.hpp	/^# define OPERATOR_OP /;"	d
PORT	1MAIN/include/main.hpp	/^# define PORT /;"	d
PORT	2TEST/new_main.cpp	/^#define PORT /;"	d	file:
PORT	2TEST/old_main.cpp	/^#define PORT /;"	d	file:
QUEUE_SIZE	1MAIN/include/main.hpp	/^# define QUEUE_SIZE /;"	d
QUEUE_SIZE	2TEST/new_main.cpp	/^#define QUEUE_SIZE /;"	d	file:
QUEUE_SIZE	2TEST/old_main.cpp	/^#define QUEUE_SIZE /;"	d	file:
SERVER_HPP	1MAIN/include/Server.hpp	/^# define SERVER_HPP$/;"	d
SERV_NAME	1MAIN/include/Server.hpp	/^# define SERV_NAME /;"	d
SOURCES	0HELPER/poll/Makefile	/^SOURCES = $(foreach f, $(FILES), .\/$(f))$/;"	m
SOURCES	2TEST/Makefile	/^SOURCES = $(foreach f, $(FILES), .\/$(f))$/;"	m
SOURCES	helper/test_buid/Makefile	/^SOURCES = $(foreach f, $(FILES), .\/$(f))$/;"	m
SRCS	1MAIN/Makefile	/^SRCS = main.cpp \\$/;"	m
SRC_DIR	1MAIN/Makefile	/^SRC_DIR = src$/;"	m
Server	1MAIN/include/Server.hpp	/^class	Server$/;"	c
Server	1MAIN/src/Server.cpp	/^Server::Server(void)$/;"	f	class:Server
TOPIC_MAX_LEN	1MAIN/include/Channel.hpp	/^# define TOPIC_MAX_LEN /;"	d
TOPIC_RESTRICT	1MAIN/include/Channel.hpp	/^# define TOPIC_RESTRICT /;"	d
TRIMMED_CHARS	1MAIN/src/utils_strings.cpp	/^# define TRIMMED_CHARS /;"	d	file:
UTILS_STRINGS_H	1MAIN/include/utils_strings.hpp	/^#define UTILS_STRINGS_H$/;"	d
VECTOR_UTILS_H	1MAIN/include/vector_utils.hpp	/^#define VECTOR_UTILS_H$/;"	d
__glibc_reserved	0HELPER/manual.h	/^	long			__glibc_reserved[3];$/;"	m	struct:stat	typeref:typename:long[3]
_hostname	1MAIN/include/Client.hpp	/^    std::string         		_hostname;$/;"	m	class:Client	typeref:typename:std::string
_key	1MAIN/include/Channel.hpp	/^    std::string _key;$/;"	m	class:Channel	typeref:typename:std::string
_name	1MAIN/include/Channel.hpp	/^    std::string _name;$/;"	m	class:Channel	typeref:typename:std::string
_name	1MAIN/include/Server.hpp	/^    std::string _name;$/;"	m	class:Server	typeref:typename:std::string
_nickname	1MAIN/include/Client.hpp	/^    std::string         		_nickname;$/;"	m	class:Client	typeref:typename:std::string
_realname	1MAIN/include/Client.hpp	/^    std::string         		_realname;$/;"	m	class:Client	typeref:typename:std::string
_topic	1MAIN/include/Channel.hpp	/^    std::string _topic;$/;"	m	class:Channel	typeref:typename:std::string
_username	1MAIN/include/Client.hpp	/^    std::string         		_username;$/;"	m	class:Client	typeref:typename:std::string
addrinfo	0HELPER/manual.h	/^struct addrinfo$/;"	s
admins	1MAIN/include/Channel.hpp	/^    std::vector<Client> admins;$/;"	m	class:Channel	typeref:typename:std::vector<Client>
ai_addr	0HELPER/manual.h	/^	struct sockaddr*	ai_addr;		\/\/ Socket address for socket.$/;"	m	struct:addrinfo	typeref:struct:sockaddr *
ai_addrlen	0HELPER/manual.h	/^	socklen_t			ai_addrlen;		\/\/ Length of socket address.$/;"	m	struct:addrinfo	typeref:typename:socklen_t
ai_canonname	0HELPER/manual.h	/^	char*				ai_canonname;	\/\/ Canonical name for service location.$/;"	m	struct:addrinfo	typeref:typename:char *
ai_family	0HELPER/manual.h	/^	int					ai_family;		\/\/ Protocol family for socket.$/;"	m	struct:addrinfo	typeref:typename:int
ai_flags	0HELPER/manual.h	/^	int					ai_flags;		\/\/ Input flags.$/;"	m	struct:addrinfo	typeref:typename:int
ai_next	0HELPER/manual.h	/^	struct addrinfo*	ai_next;		\/\/ Pointer to next in list.$/;"	m	struct:addrinfo	typeref:struct:addrinfo *
ai_protocol	0HELPER/manual.h	/^	int					ai_protocol;	\/\/ Protocol for socket.$/;"	m	struct:addrinfo	typeref:typename:int
ai_socktype	0HELPER/manual.h	/^	int					ai_socktype;	\/\/ Socket type.$/;"	m	struct:addrinfo	typeref:typename:int
all	0HELPER/poll/Makefile	/^all: $(NAME)$/;"	t
all	1MAIN/Makefile	/^all: $(NAME)$/;"	t
all	2TEST/Makefile	/^all: $(NAME)$/;"	t
all	helper/test_buid/Makefile	/^all: $(NAME)$/;"	t
bindServerSocket	1MAIN/src/Server.cpp	/^void				Server::bindServerSocket(void)$/;"	f	class:Server	typeref:typename:void
buffer	1MAIN/include/Server.hpp	/^	char				buffer[BUFFER_SIZE];$/;"	m	class:Server	typeref:typename:char[]
capEnd	1MAIN/src/capabilities.cpp	/^void capEnd(Server &server, Client &client, std::string caps) {$/;"	f	typeref:typename:void
capLs	1MAIN/src/capabilities.cpp	/^void capLs(Server& server, Client& client, std::string args)$/;"	f	typeref:typename:void
capReq	1MAIN/src/capabilities.cpp	/^void capReq(Server& server, Client& client, std::string caps)$/;"	f	typeref:typename:void
cap_tab	1MAIN/src/capabilities.cpp	/^const struct s_cmd cap_tab[] = {$/;"	v	typeref:typename:const struct s_cmd[]
capabilities	1MAIN/include/Client.hpp	/^	std::vector<std::string>    capabilities;$/;"	m	class:Client	typeref:typename:std::vector<std::string>
channels	1MAIN/include/Client.hpp	/^    std::vector<Channel>    	channels;$/;"	m	class:Client	typeref:typename:std::vector<Channel>
channels	1MAIN/include/Server.hpp	/^    std::vector<Channel> channels;$/;"	m	class:Server	typeref:typename:std::vector<Channel>
clean	0HELPER/poll/Makefile	/^clean:$/;"	t
clean	1MAIN/Makefile	/^clean:$/;"	t
clean	2TEST/Makefile	/^clean:$/;"	t
clean	helper/test_buid/Makefile	/^clean:$/;"	t
clientCleanup	1MAIN/src/Client.cpp	/^void Client::clientCleanup(void)$/;"	f	class:Client	typeref:typename:void
client_addrlen	1MAIN/include/Client.hpp	/^	socklen_t			client_addrlen;$/;"	m	class:Client	typeref:typename:socklen_t
clients	1MAIN/include/Channel.hpp	/^    std::vector<Client> clients;$/;"	m	class:Channel	typeref:typename:std::vector<Client>
cmdCap	1MAIN/src/Handle.cpp	/^void cmdCap(Server &server, Client &client, std::string args) {$/;"	f	typeref:typename:void
cmdJoin	1MAIN/src/Handle.cpp	/^void cmdJoin(Server &server, Client &client, std::string input) {$/;"	f	typeref:typename:void
cmdKick	1MAIN/src/Handle.cpp	/^void cmdKick(Server &server, Client &client, std::string input) {$/;"	f	typeref:typename:void
cmdMode	1MAIN/src/Handle.cpp	/^void cmdMode(Server &server, Client &client, std::string input) {$/;"	f	typeref:typename:void
cmdNick	1MAIN/src/Handle.cpp	/^void cmdNick(Server &server, Client &client, std::string input) {$/;"	f	typeref:typename:void
cmdPing	1MAIN/src/Handle.cpp	/^void    cmdPing(Server &server, Client &client, std::string input)$/;"	f	typeref:typename:void
cmdPrivmsg	1MAIN/src/Handle.cpp	/^void cmdPrivmsg(Server &server, Client &client, std::string input)$/;"	f	typeref:typename:void
cmdTopic	1MAIN/src/Handle.cpp	/^void    cmdTopic(Server &server, Client &client, std::string input)$/;"	f	typeref:typename:void
cmdUser	1MAIN/src/Handle.cpp	/^void cmdUser(Server &server, Client &client, std::string input) {$/;"	f	typeref:typename:void
cmdUserHost	1MAIN/src/Handle.cpp	/^void cmdUserHost(Server &server, Client &client, std::string input)$/;"	f	typeref:typename:void
cmdWho	1MAIN/src/Handle.cpp	/^void cmdWho(Server &server, Client &client, std::string input)$/;"	f	typeref:typename:void
commands	1MAIN/include/Handle.hpp	/^static const struct s_cmd commands [] = {$/;"	v	typeref:typename:const struct s_cmd[]
debug	1MAIN/Makefile	/^debug: $(NAME)_debug$/;"	t
debug	1MAIN/Makefile	/^debug: CXXFLAGS += $(DEBUG_FLAGS)$/;"	t
debug_re	1MAIN/Makefile	/^debug_re: fclean debug$/;"	t
del	1MAIN/include/vector_utils.hpp	/^void del(std::vector<T>& v, T x) {$/;"	f	typeref:typename:void
delChannel	1MAIN/src/Client.cpp	/^void Client::delChannel(Channel& channel) {$/;"	f	class:Client	typeref:typename:void
delChannel	1MAIN/src/Server.cpp	/^void Server::delChannel(Channel &channel) {$/;"	f	class:Server	typeref:typename:void
delClient	1MAIN/src/Channel.cpp	/^void Channel::delClient(Client &client) {$/;"	f	class:Channel	typeref:typename:void
delOp	1MAIN/src/Channel.cpp	/^void    Channel::delOp(std::string op) {$/;"	f	class:Channel	typeref:typename:void
errExit	0HELPER/poll/main.cpp	/^#define errExit(/;"	d	file:
err_check	1MAIN/include/main.hpp	/^	int					err_check;$/;"	m	struct:poll_data	typeref:typename:int
events	0HELPER/manual.h	/^	short int	events;		\/\/ Types of events poller cares about.$/;"	m	struct:pollfd	typeref:typename:short int
f	1MAIN/include/Handle.hpp	/^    CommandFunc f;$/;"	m	struct:s_cmd	typeref:typename:CommandFunc
fclean	0HELPER/poll/Makefile	/^fclean: clean$/;"	t
fclean	1MAIN/Makefile	/^fclean: clean$/;"	t
fclean	2TEST/Makefile	/^fclean: clean$/;"	t
fclean	helper/test_buid/Makefile	/^fclean: clean$/;"	t
fd	0HELPER/manual.h	/^	int			fd;			\/\/ File descriptor to poll.$/;"	m	struct:pollfd	typeref:typename:int
fd_client_socket	1MAIN/include/Client.hpp	/^	int					fd_client_socket;$/;"	m	class:Client	typeref:typename:int
fd_nb	1MAIN/include/main.hpp	/^	int					fd_nb;$/;"	m	struct:poll_data	typeref:typename:int
fd_server_socket	1MAIN/include/Server.hpp	/^	int					fd_server_socket;$/;"	m	class:Server	typeref:typename:int
fds	1MAIN/include/main.hpp	/^	struct pollfd		fds[MAX_CONNECTIONS];$/;"	m	struct:poll_data	typeref:struct:pollfd[]
flags	1MAIN/include/Client.hpp	/^    std::vector<std::string>    flags;$/;"	m	class:Client	typeref:typename:std::vector<std::string>
getChannel	1MAIN/src/Server.cpp	/^Channel	&Server::getChannel(std::string const &channel_str)$/;"	f	class:Server	typeref:typename:Channel &
getClient	1MAIN/src/Server.cpp	/^Client &Server::getClient(const std::string &nick)$/;"	f	class:Server	typeref:typename:Client &
getClient	1MAIN/src/Server.cpp	/^Client&	Server::getClient(int i) {$/;"	f	class:Server	typeref:typename:Client &
getHead	1MAIN/src/utils_strings.cpp	/^std::string getHead(const std::string& str)$/;"	f	typeref:typename:std::string
getName	1MAIN/src/Server.cpp	/^std::string &Server::getName(void) {$/;"	f	class:Server	typeref:typename:std::string &
getNextWds	1MAIN/src/utils_strings.cpp	/^std::string getNextWds(const std::string& str)$/;"	f	typeref:typename:std::string
h_addr	0HELPER/manual.h	/^typedef char*	h_addr;$/;"	t	typeref:typename:char *
h_addr_list	0HELPER/manual.h	/^	char**	h_addr_list;	\/\/ List of addresses from name server.$/;"	m	struct:hostent	typeref:typename:char **
h_addr_list	0HELPER/manual.h	/^	h_addr	h_addr_list[0];	\/\/ Address, for backward compatibility.$/;"	m	struct:hostent	typeref:typename:h_addr[0]
h_addrtype	0HELPER/manual.h	/^	int		h_addrtype;		\/\/ Host address type.$/;"	m	struct:hostent	typeref:typename:int
h_aliases	0HELPER/manual.h	/^	char**	h_aliases;		\/\/ Alias list.$/;"	m	struct:hostent	typeref:typename:char **
h_length	0HELPER/manual.h	/^	int		h_length;		\/\/ Length of address.$/;"	m	struct:hostent	typeref:typename:int
h_name	0HELPER/manual.h	/^	char*	h_name;			\/\/ Official name of host.$/;"	m	struct:hostent	typeref:typename:char *
handle	1MAIN/src/Server.cpp	/^void	Server::handle(char *buffer, Client &client) {$/;"	f	class:Server	typeref:typename:void
has	1MAIN/include/vector_utils.hpp	/^bool has(std::vector<T> v, T x) {$/;"	f	typeref:typename:bool
hasCap	1MAIN/src/Client.cpp	/^bool    Client::hasCap(const std::string &cap)$/;"	f	class:Client	typeref:typename:bool
hasChannel	1MAIN/src/Server.cpp	/^bool	Server::hasChannel(std::string const &nick)$/;"	f	class:Server	typeref:typename:bool
hasFlag	1MAIN/src/Client.cpp	/^bool    Client::hasFlag(const std::string &cap)$/;"	f	class:Client	typeref:typename:bool
hasNick	1MAIN/src/Server.cpp	/^bool	Server::hasNick(std::string const &nick)$/;"	f	class:Server	typeref:typename:bool
hasOp	1MAIN/src/Channel.cpp	/^bool    Channel::hasOp(std::string op) {$/;"	f	class:Channel	typeref:typename:bool
hasUser	1MAIN/src/Server.cpp	/^bool	Server::hasUser(std::string const &nick)$/;"	f	class:Server	typeref:typename:bool
header	1MAIN/include/Handle.hpp	/^    const char* header;$/;"	m	struct:s_cmd	typeref:typename:const char *
hostent	0HELPER/manual.h	/^typedef struct	hostent$/;"	s
i	1MAIN/include/main.hpp	/^	int					i;$/;"	m	struct:poll_data	typeref:typename:int
in_addr	0HELPER/manual.h	/^struct in_addr$/;"	s
in_addr_t	0HELPER/manual.h	/^typedef uint32_t	in_addr_t;$/;"	t	typeref:typename:uint32_t
initServerSocket	1MAIN/src/Server.cpp	/^void				Server::initServerSocket(void)$/;"	f	class:Server	typeref:typename:void
irc	README.md	/^# irc$/;"	c
isAdmin	1MAIN/src/Channel.cpp	/^bool Channel::isAdmin(Client &client) {$/;"	f	class:Channel	typeref:typename:bool
isCap	1MAIN/src/capabilities.cpp	/^bool isCap(const std::string& cap)$/;"	f	typeref:typename:bool
isClient	1MAIN/src/Channel.cpp	/^bool Channel::isClient(Client &client) {$/;"	f	class:Channel	typeref:typename:bool
isValidName	1MAIN/src/utils_strings.cpp	/^bool isValidName(const std::string& str)$/;"	f	typeref:typename:bool
is_in	1MAIN/include/vector_utils.hpp	/^bool is_in(std::vector<T> &v, const T x)$/;"	f	typeref:typename:bool
listenServerSocket	1MAIN/src/Server.cpp	/^void				Server::listenServerSocket(void)$/;"	f	class:Server	typeref:typename:void
lowerCase	1MAIN/src/utils_strings.cpp	/^std::string lowerCase(const std::string& str)$/;"	f	typeref:typename:std::string
main	0HELPER/poll/main.cpp	/^int	main(int argc, char *argv[])$/;"	f	typeref:typename:int
main	1MAIN/src/main.cpp	/^int main(int argc, char **argv)$/;"	f	typeref:typename:int
main	2TEST/new_main.cpp	/^int	main(void)$/;"	f	typeref:typename:int
main	2TEST/old_main.cpp	/^int	main(void)$/;"	f	typeref:typename:int
multiPrefix	1MAIN/src/capabilities.cpp	/^void multiPrefix(Server& server, Client& client, std::string input)$/;"	f	typeref:typename:void
newChannel	1MAIN/src/Client.cpp	/^Channel* Client::newChannel(std::string& name)$/;"	f	class:Client	typeref:typename:Channel *
nfds_t	0HELPER/manual.h	/^typedef unsigned long int	nfds_t;$/;"	t	typeref:typename:unsigned long int
off_t	0HELPER/manual.h	/^typedef long	off_t;$/;"	t	typeref:typename:long
op	1MAIN/include/Channel.hpp	/^    std::vector<std::string> op;$/;"	m	class:Channel	typeref:typename:std::vector<std::string>
operator =	1MAIN/src/Channel.cpp	/^Channel& Channel::operator=(const Channel& other) {$/;"	f	class:Channel	typeref:typename:Channel &
operator ==	1MAIN/src/Channel.cpp	/^bool Channel::operator==(const Channel &other) const {$/;"	f	class:Channel	typeref:typename:bool
operator ==	1MAIN/src/Client.cpp	/^bool Client::operator==(const Client& other) const$/;"	f	class:Client	typeref:typename:bool
p_aliases	0HELPER/manual.h	/^	char**	p_aliases;	\/\/ Alias list.$/;"	m	struct:protoent	typeref:typename:char **
p_name	0HELPER/manual.h	/^	char*	p_name;		\/\/ Official protocol name.$/;"	m	struct:protoent	typeref:typename:char *
p_proto	0HELPER/manual.h	/^	int		p_proto;		\/\/ Protocol number.$/;"	m	struct:protoent	typeref:typename:int
paint	3UMLET/custom_elements/AutoResize1.java	/^	public void paint() {$/;"	m	class:__anon1
paint	3UMLET/custom_elements/AutoResize2.java	/^	public void paint() {$/;"	m	class:__anon1
paint	3UMLET/custom_elements/Default.java	/^	public void paint() {$/;"	m	class:__anon1
paint	3UMLET/custom_elements/RectangleRound.java	/^	public void paint() {$/;"	m	class:__anon1
paint	3UMLET/custom_elements/WordWrap.java	/^	public void paint() {$/;"	m	class:__anon1
pollClientConnect	1MAIN/src/Poll.cpp	/^void	Server::pollClientConnect(poll_data* p_data)$/;"	f	class:Server	typeref:typename:void
pollClientDisconnect	1MAIN/src/Poll.cpp	/^void	Server::pollClientDisconnect(poll_data* p_data)$/;"	f	class:Server	typeref:typename:void
pollClientHandler	1MAIN/src/Poll.cpp	/^void Server::pollClientHandler(poll_data* p_data)$/;"	f	class:Server	typeref:typename:void
pollClientRecv	1MAIN/src/Poll.cpp	/^void	Server::pollClientRecv(poll_data* p_data)$/;"	f	class:Server	typeref:typename:void
pollDataCleanup	1MAIN/src/main.cpp	/^void	pollDataCleanup(poll_data* poll_data)$/;"	f	typeref:typename:void
pollFailHandler	1MAIN/src/Poll.cpp	/^void Server::pollFailHandler(poll_data* p_data)$/;"	f	class:Server	typeref:typename:void
pollLoop	1MAIN/src/Poll.cpp	/^void Server::pollLoop(void)$/;"	f	class:Server	typeref:typename:void
poll_data	1MAIN/include/main.hpp	/^struct poll_data$/;"	s
pollfd	0HELPER/manual.h	/^typedef struct	pollfd$/;"	s
processCommand	1MAIN/src/Handle.cpp	/^void processCommand(Server &server, Client &client, std::string input) {$/;"	f	typeref:typename:void
protoent	0HELPER/manual.h	/^typedef struct	protoent$/;"	s
pushChannel	1MAIN/src/Server.cpp	/^void Server::pushChannel(Channel &channel) {$/;"	f	class:Server	typeref:typename:void
re	0HELPER/poll/Makefile	/^re: fclean all$/;"	t
re	1MAIN/Makefile	/^re: fclean all$/;"	t
re	2TEST/Makefile	/^re: fclean all$/;"	t
re	helper/test_buid/Makefile	/^re: fclean all$/;"	t
resetCap	1MAIN/src/Client.cpp	/^void Client::resetCap(const std::string &cap)$/;"	f	class:Client	typeref:typename:void
resetFlag	1MAIN/src/Client.cpp	/^void Client::resetFlag(const std::string &cap)$/;"	f	class:Client	typeref:typename:void
revents	0HELPER/manual.h	/^	short int	revents;	\/\/ Types of events that actually occurred.$/;"	m	struct:pollfd	typeref:typename:short int
s_addr	0HELPER/manual.h	/^	in_addr_t	s_addr;$/;"	m	struct:in_addr	typeref:typename:in_addr_t
s_cmd	1MAIN/include/Handle.hpp	/^struct s_cmd {$/;"	s
sa_data	0HELPER/manual.h	/^	char			sa_data[14];	\/\/ Address data.$/;"	m	struct:sockaddr	typeref:typename:char[14]
sa_family	0HELPER/manual.h	/^	unsigned short	sa_family;		\/\/ Common data: address family and length.$/;"	m	struct:sockaddr	typeref:typename:unsigned short
send	1MAIN/src/Client.cpp	/^ssize_t Client::send(std::string msg)$/;"	f	class:Client	typeref:typename:ssize_t
sendClient	1MAIN/src/Server.cpp	/^ssize_t 		Server::sendClient(Client &cli, std::string msg) {$/;"	f	class:Server	typeref:typename:ssize_t
send_banner	1MAIN/src/Client.cpp	/^ssize_t Client::send_banner(std::string line)$/;"	f	class:Client	typeref:typename:ssize_t
server	1MAIN/include/Client.hpp	/^    Server              		*server;$/;"	m	class:Client	typeref:typename:Server *
serverCleanup	1MAIN/src/Server.cpp	/^void				Server::serverCleanup(void)$/;"	f	class:Server	typeref:typename:void
serverSetup	1MAIN/src/Server.cpp	/^void	Server::serverSetup(void)$/;"	f	class:Server	typeref:typename:void
server_banner	1MAIN/src/capabilities.cpp	/^static void server_banner(Client &client)$/;"	f	typeref:typename:void	file:
set	1MAIN/include/vector_utils.hpp	/^void set(std::vector<T> &v, const T x) {$/;"	f	typeref:typename:void
setAdmin	1MAIN/src/Channel.cpp	/^void Channel::setAdmin(Client &client) {$/;"	f	class:Channel	typeref:typename:void
setCap	1MAIN/src/Client.cpp	/^void	Client::setCap(const std::string &cap)$/;"	f	class:Client	typeref:typename:void
setClient	1MAIN/src/Channel.cpp	/^void Channel::setClient(Client &client) {$/;"	f	class:Channel	typeref:typename:void
setFlag	1MAIN/src/Client.cpp	/^void	Client::setFlag(const std::string &cap)$/;"	f	class:Client	typeref:typename:void
setOp	1MAIN/src/Channel.cpp	/^void    Channel::setOp(std::string op) {$/;"	f	class:Channel	typeref:typename:void
setServerSockopt	1MAIN/src/Server.cpp	/^void				Server::setServerSockopt(void)$/;"	f	class:Server	typeref:typename:void
size_t	0HELPER/manual.h	/^typedef unsigned long		size_t;$/;"	t	typeref:typename:unsigned long
sockaddr	0HELPER/manual.h	/^typedef struct	sockaddr$/;"	s
socklen_t	0HELPER/manual.h	/^typedef unsigned int		socklen_t;$/;"	t	typeref:typename:unsigned int
spawn	1MAIN/src/Channel.cpp	/^void Channel::spawn(std::string msg)$/;"	f	class:Channel	typeref:typename:void
ssize_t	0HELPER/manual.h	/^typedef unsigned long long	ssize_t;$/;"	t	typeref:typename:unsigned long long
st_atime	0HELPER/manual.h	/^	long			st_atime;		\/\/ Time of last access.$/;"	m	struct:stat	typeref:typename:long
st_atimensec	0HELPER/manual.h	/^	unsigned long	st_atimensec;	\/\/ Nscecs of last access.$/;"	m	struct:stat	typeref:typename:unsigned long
st_blksize	0HELPER/manual.h	/^	long			st_blksize;		\/\/ Optimal block size for I\/O.$/;"	m	struct:stat	typeref:typename:long
st_blocks	0HELPER/manual.h	/^	long			st_blocks;		\/\/ Number 512-byte blocks allocated.$/;"	m	struct:stat	typeref:typename:long
st_ctime	0HELPER/manual.h	/^	long			st_ctime;		\/\/ Time of last status change.$/;"	m	struct:stat	typeref:typename:long
st_ctimensec	0HELPER/manual.h	/^	long			st_ctimensec;	\/\/ Nsecs of last status change.$/;"	m	struct:stat	typeref:typename:long
st_dev	0HELPER/manual.h	/^	unsigned long	st_dev;			\/\/ Device.$/;"	m	struct:stat	typeref:typename:unsigned long
st_gid	0HELPER/manual.h	/^	unsigned int	st_gid;			\/\/ Group ID of the file's group.$/;"	m	struct:stat	typeref:typename:unsigned int
st_ino	0HELPER/manual.h	/^	unsigned long	st_ino;			\/\/ File serial number.$/;"	m	struct:stat	typeref:typename:unsigned long
st_mode	0HELPER/manual.h	/^	unsigned int	st_mode;		\/\/ File mode.$/;"	m	struct:stat	typeref:typename:unsigned int
st_mtime	0HELPER/manual.h	/^	long			st_mtime;		\/\/ Time of last modification.$/;"	m	struct:stat	typeref:typename:long
st_mtimensec	0HELPER/manual.h	/^	unsigned long	st_mtimensec;	\/\/ Nsecs of last modification.$/;"	m	struct:stat	typeref:typename:unsigned long
st_nlink	0HELPER/manual.h	/^	unsigned long	st_nlink;		\/\/ Link count.$/;"	m	struct:stat	typeref:typename:unsigned long
st_rdev	0HELPER/manual.h	/^	unsigned long	st_rdev;		\/\/ Device number, if device.$/;"	m	struct:stat	typeref:typename:unsigned long
st_size	0HELPER/manual.h	/^	long			st_size;		\/\/ Size of file, in bytes.$/;"	m	struct:stat	typeref:typename:long
st_uid	0HELPER/manual.h	/^	unsigned int	st_uid;			\/\/ User ID of the file's owner.$/;"	m	struct:stat	typeref:typename:unsigned int
stat	0HELPER/manual.h	/^typedef struct stat$/;"	s
to_string	1MAIN/src/utils_strings.cpp	/^std::string to_string(const ssize_t value) {$/;"	f	typeref:typename:std::string
trim	1MAIN/src/utils_strings.cpp	/^std::string trim(const std::string& str)$/;"	f	typeref:typename:std::string
trim	1MAIN/src/utils_strings.cpp	/^std::string trim(const std::string& str, const std::string& chars)$/;"	f	typeref:typename:std::string
upperCase	1MAIN/src/utils_strings.cpp	/^std::string upperCase(const std::string& str)$/;"	f	typeref:typename:std::string
vector_clients	1MAIN/include/Server.hpp	/^	std::vector<Client>	vector_clients;$/;"	m	class:Server	typeref:typename:std::vector<Client>
~Channel	1MAIN/src/Channel.cpp	/^Channel::~Channel() {$/;"	f	class:Channel
~Client	1MAIN/src/Client.cpp	/^Client::~Client(void)$/;"	f	class:Client
~Server	1MAIN/src/Server.cpp	/^Server::~Server(void)$/;"	f	class:Server
